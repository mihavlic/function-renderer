#version 450
#extension GL_EXT_scalar_block_layout : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_ballot : enable

layout (set = 0, binding = 0, rgba8) uniform readonly image3D intersections;
layout (set = 0, binding = 1, r32ui) uniform writeonly uimage3D vertex_indices;
layout(set = 0, binding = 2, scalar) buffer vertexData {
    uint size;
    uint offset;
	vec3 vertices[];
} vertices;

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

const uvec3[] axes = {
    {1,0,0},
    {0,1,0},
    {0,0,1}
};

float plane_distance(vec3 normal, vec3 intersection, vec3 point) {
    // ax + by + cz - q = 0
    float q = dot(normal, intersection);
    // normal is expected to be notmalized
    return dot(normal, point) - q;
}

vec4 get_edge(uvec3 pos, uint axis) {
    uvec3 index = uvec3(pos.x + axis * 64, pos.xy);
    return imageLoad(intersections, ivec3(index));
}

const uint INDEX_INVALID = 4294967295;

void main() {
    uvec3 global_id = gl_GlobalInvocationID.xyz;

    //       ______2______           H___________G
    //      /|           /|         /|           /
    //     5 |11        6 |        / |          /|
    //    /  |         /  |10     /  |         / |
    //   |------3-----|   |      E------------F  |
    //   |   |_____1__|___|      |   D________|__C
    //   |   /        |   /      |   /        |  /
    //  8|  4        9|  7       |  /         | /      z  y
    //   | /          | /        | /          |/       | /
    //   |/___________|/         A/___________B        |/___ x
    //          0

    uvec3 A = global_id;
    uvec3 B = A + uvec3(1, 0, 0);
    uvec3 C = A + uvec3(1, 1, 0);
    uvec3 D = A + uvec3(0, 1, 0);
    uvec3 E = A + uvec3(0, 0, 1);
    uvec3 F = A + uvec3(1, 0, 1);
    uvec3 G = A + uvec3(1, 1, 1);
    uvec3 H = A + uvec3(0, 1, 1);

    vec4 edges[12] = {
        get_edge(A, 0),
        get_edge(D, 0),
        get_edge(H, 0),
        get_edge(E, 0),

        get_edge(A, 1),
        get_edge(E, 1),
        get_edge(F, 1),
        get_edge(B, 1),

        get_edge(A, 2),
        get_edge(B, 2),
        get_edge(C, 2),
        get_edge(D, 2),
    };

    uvec3 edge_vertices[12] = {
        A,
        D,
        H,
        E,
        A,
        E,
        F,
        B,
        A,
        B,
        C,
        D
    };

    // xyz(edge intersection) w(plane q parameter)
    vec4 edge_intersections[12];

    vec3 intersections_sum = vec3(0.0);
    uint intersections_count = 0;
    for (int i = 0; i < 12; i++) {
        vec4 intersection = edges[i];
        // zero is a special value
        if (intersection.w != 0.0) {
            vec3 cellspace_point = vec3(edge_vertices[i]) + intersection.w * axes[i / 4];

            // ax + by + cz + q = 0
            float q = -dot(intersection.xyz, cellspace_point);

            edge_intersections[i] = vec4(cellspace_point, q);
            intersections_sum += cellspace_point;
            intersections_count += 1;
        }
    }

    // this cell has no intersections, we can exit
    if (intersections_count == 0) {
        imageStore(vertex_indices, ivec3(global_id.xyz), uvec4(INDEX_INVALID));
        return;
    }

    vec3 mass_point = intersections_sum / float(intersections_count);

    // iteratively move the point according to the distance from the intersection planes
    for (int iter = 0; iter < 5; iter++) {
        vec3 force = vec3(0.0);
        for (int i = 0; i < 12; i++) {
            vec4 intersection = edges[i];
            if (intersection.w != 0.0) {
                vec3 normal = intersection.xyz;
                float q = edge_intersections[i].w;

                float plane_distance = dot(normal, mass_point) + q;
                force += plane_distance * normal;
            }

        }
        mass_point += force * float(intersections_count);
    }

    // we are bump allocating vertices, a stream compaction pass would probably be more efficient
    // but it seems to be very complicated and no very worth it at this stage
    // instead we use subgroup operation to do a prefix some over invocations which have a vertex to
    // write and then bump allocate this whole block, then each invocation writes its vertex to the predetermined index

    // prefix sum to find out the subgroup local index of the output vertex
    uint inclusive_vertex_batch_offset = subgroupInclusiveAdd(1);
    // is there a better way to do this?
    uint total = subgroupMax(inclusive_vertex_batch_offset);

    // the first invocation does the bump allocation
    uint batch_offset;
    if (subgroupElect()) {
        batch_offset = atomicAdd(vertices.offset, total);
    }

    // let the first invocation broadcast the batch offset to the other invocations
    uint broadcast_batch_offset = subgroupBroadcastFirst(batch_offset);

    // -1 since the prefix sum is inclusive of the calling invocation
    uint index = broadcast_batch_offset + inclusive_vertex_batch_offset - 1;

    if (index < vertices.size) {
        vertices.vertices[index];
    } else {
        // if we've reached the capacity of the vertex buffer, just throw away the vertex
        index = INDEX_INVALID;
    }

    imageStore(vertex_indices, ivec3(global_id.xyz), uvec4(index));

}
