#version 450
#extension GL_EXT_scalar_block_layout : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_ballot : enable

layout (set = 0, binding = 0, r16) uniform readonly image3D function_values;
layout (set = 0, binding = 1, r32ui) uniform readonly uimage3D vertex_indices;
layout(set = 0, binding = 2, scalar) buffer indexData {
    uint size;
    uint offset;
	uint indices[];
} indices;

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

const uvec3[] axes = {
    {1,0,0},
    {0,1,0},
    {0,0,1}
};

const uint INDEX_INVALID = 4294967295;

bool vertex_is_positive(uvec3 pos) {
    return imageLoad(function_values, ivec3(pos)).x >= 0.0;
}

uint get_cell_vertex_index(uvec3 pos) {
    return imageLoad(vertex_indices, ivec3(pos)).x;
}

void main() {
    uvec3 global_id = gl_GlobalInvocationID.xyz;

    //       ______2______           H___________G
    //      /|           /|         /|           /
    //     5 |11        6 |        / |          /|
    //    /  |         /  |10     /  |         / |
    //   |------3-----|   |      E------------F  |
    //   |   |_____1__|___|      |   D________|__C
    //   |   /        |   /      |   /        |  /
    //  8|  4        9|  7       |  /         | /      z  y
    //   | /          | /        | /          |/       | /
    //   |/___________|/         A/___________B        |/___ x
    //          0

    if (global_id.x == 64 || global_id.y == 64 || global_id.z == 64) {
        return;
    }

    uint v0 = get_cell_vertex_index(global_id);

    if (v0 == INDEX_INVALID) {
        return;
    }

    uvec3 A = global_id;
    uvec3 B = A + uvec3(1, 0, 0);
    uvec3 C = A + uvec3(1, 1, 0);
    uvec3 D = A + uvec3(0, 1, 0);
    uvec3 G = A + uvec3(1, 1, 1);
    
    bool signs[4] = {
        vertex_is_positive(B),
        vertex_is_positive(C),
        vertex_is_positive(D),
        vertex_is_positive(G)
    };

    uvec2 edges[3] = {
        {0, 1},
        {1, 2},
        {1, 3}
    };
    
    int triangle_indices_offset = 0;
    uint triangle_indices[3 * 2 * 3];

    for (int axis = 0; axis < 3; axis++) {
        uvec2 edge = edges[axis];

        if (signs[edge.x] == signs[edge.y]) {
            // no intersection
            continue;
        }
        
        uint v1, v2, v3;
        
        if (axis == 0) {
            v1 = get_cell_vertex_index(A + uvec3(0,0,1));
            v2 = get_cell_vertex_index(A + uvec3(0,1,0));
            v3 = get_cell_vertex_index(A + uvec3(0,1,1));
        } else if (axis == 1) {
            v1 = get_cell_vertex_index(A + uvec3(0,0,1));
            v2 = get_cell_vertex_index(A + uvec3(1,0,0));
            v3 = get_cell_vertex_index(A + uvec3(1,0,1));
        } else {
            v1 = get_cell_vertex_index(A + uvec3(0,1,0));
            v2 = get_cell_vertex_index(A + uvec3(1,0,0));
            v3 = get_cell_vertex_index(A + uvec3(1,1,0));
        }
        
        // if (v1 == INDEX_INVALID || v2 == INDEX_INVALID || v3 == INDEX_INVALID)
        // {
        //     // Shouldn't ever happen
        //     // kinda can't do error reporting from the shader
        //     // also this may happen when we've run out ofspace in the vertex buffer in the previous pass
        // }

        int o = triangle_indices_offset;
        triangle_indices[o + 0] = v0;
        triangle_indices[o + 1] = v1;
        triangle_indices[o + 2] = v3;
        triangle_indices[o + 3] = v0;
        triangle_indices[o + 4] = v3;
        triangle_indices[o + 5] = v2;

        triangle_indices_offset += 6;
    }

    // do the subgroup bump allocation dance again

    // prefix sum to find out the subgroup local index of the output vertex
    uint inclusive_vertex_batch_offset = subgroupInclusiveAdd(triangle_indices_offset);
    // is there a better way to do this?
    uint total = subgroupMax(inclusive_vertex_batch_offset);

    // the first invocation does the bump allocation
    uint batch_offset;
    if (subgroupElect()) {
        batch_offset = atomicAdd(indices.offset, total);
    }

    // let the first invocation broadcast the batch offset to the other invocations
    uint broadcast_batch_offset = subgroupBroadcastFirst(batch_offset);

    uint index = broadcast_batch_offset + inclusive_vertex_batch_offset - triangle_indices_offset;

    // if we've reached the capacity of the vertex buffer, just throw away the triangles
    if (index < indices.size) {
        // copy thr indices to the storage buffer
        for (int i = 0; i < triangle_indices_offset; i++) {
            indices.indices[index + i] = triangle_indices[i];
        }
    }

}
